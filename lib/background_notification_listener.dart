// You have generated a new plugin project without specifying the `--platforms`
// flag. A plugin project with no platform support was generated. To add a
// platform, run `flutter create -t plugin --platforms <platforms> .` under the
// same directory. You can also find a detailed instruction on how to add
// platforms in the `pubspec.yaml` at
// https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin-platforms.

import 'dart:convert';
import 'dart:ui';

import 'package:background_notification_listener/background_notification_listener_platform_interface.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class BackgroundNotificationListener {
  static Future<bool?> hasPermission() async {
    return BackgroundNotificationListenerPlatform.instance.hasPermission();
  }

  static Future<bool?> openSettings() async {
    return BackgroundNotificationListenerPlatform.instance.openSettings();
  }

  static Future<void> initializeCallState(
    Function(Notification) onEventCallbackDispatcher,
  ) async {
    final callback = PluginUtilities.getCallbackHandle(_callbackDispatcher);
    final onEventCallback =
        PluginUtilities.getCallbackHandle(onEventCallbackDispatcher);

    try {
      await BackgroundNotificationListenerPlatform.instance
          .initializeNotification(
              callback!.toRawHandle(), onEventCallback!.toRawHandle());
    } on PlatformException catch (_) {
      throw Exception('Unable to initialize notification background');
    } catch (e) {
      throw Exception(e);
    }
  }
}

@pragma('vm:entry-point')
void _callbackDispatcher() {
  // 1. Initialize MethodChannel used to communicate with the platform portion of the plugin.
  const MethodChannel backgroundChannel =
      MethodChannel('background_notifications_listener_channel');

  print("enter!!!!!!");

  // 2. Setup internal state needed for MethodChannels.
  WidgetsFlutterBinding.ensureInitialized();

  // 3. Listen for background events from the platform portion of the plugin.
  backgroundChannel.setMethodCallHandler((MethodCall call) async {
    final args = call.arguments as List<dynamic>;

    // 3.1. Retrieve callback instance for handle.
    final Function? callbackHandle = PluginUtilities.getCallbackFromHandle(
      CallbackHandle.fromRawHandle(args.elementAt(1)),
    );

    late Notification notification;
    switch (call.method) {
      /// Indicates an incoming call.
      case 'notification_event':
        notification = Notification.fromMap(args[2]);
        break;

      /// Unkown event
      default:
        throw Exception('Unkown event name');
    }

    //Invoke callback.
    callbackHandle?.call(notification);
  });
}

/// NotificationEvent is the object converted from notification
/// Notification anatomy:
///   https://developer.android.com/guide/topics/ui/notifiers/notifications
class Notification {
  /// generate the unique id for notification
  /// generated by plugin
  String? uniqueId;

  /// the key of status bar notification
  String? key;

  /// the uid of status bar notification
  int? uid;

  /// the notification id
  int? id;

  /// the channel id of the notification
  String? channelId;

  /// the notification create time in flutter side
  DateTime? createAt;

  /// the nofication create time in the android side
  int? timestamp;

  /// the package name of the notification
  String? packageName;

  /// the title of the notification
  String? title;

  /// the content of the notification
  String? text;

  /// DEPRECATE
  String? message;

  /// icon of the notification which setted by setSmallIcon,
  /// at most time this is icon of the application package.
  /// So no need to set this, use a method to take from android.
  /// To display as a image use the Image.memory widget.
  /// Example:
  ///
  /// ```
  /// Image.memory(evt.icon)
  /// ```
  // Uint8List? icon;

  /// if we have the large icon
  bool? hasLargeIcon;

  /// large icon of the notification which setted by setLargeIcon.
  /// To display as a image use the Image.memory widget.
  /// Example:
  ///
  /// ```
  /// Image.memory(evt.largeIcon)
  /// ```
  Uint8List? largeIcon;

  /// if this notification can be tapped
  bool? canTap;

  /// actions of notification
  List<Action>? actions;

  /// the raw notifaction data from android
  dynamic _data;

  Notification({
    this.uniqueId,
    this.key,
    this.id,
    this.uid,
    this.channelId,
    this.createAt,
    this.packageName,
    this.title,
    this.text,
    this.message,
    this.timestamp,
    // this.icon,
    this.hasLargeIcon,
    this.largeIcon,
    this.canTap,
  });

  Map<dynamic, dynamic>? get raw => _data;

  /// Create the event from a map
  factory Notification.fromMap(Map<dynamic, dynamic> map) {
    map['hasLargeIcon'] =
        map['largeIcon'] != null && (map['largeIcon'] as Uint8List).isNotEmpty;
    var evt = Notification(
      createAt: DateTime.now(),
      uniqueId: map["_id"],
      key: map["key"],
      uid: map['uid'],
      channelId: map["channelId"],
      id: map['id'],
      packageName: map['packageName'],
      title: map['title'],
      text: map['text'],
      message: map["message"],
      timestamp: map["timestamp"],
      // icon: map['icon'],
      hasLargeIcon: map['hasLargeIcon'],
      largeIcon: map['largeIcon'],
      canTap: map["canTap"],
    );

    // set the raw data
    evt._data = map;
    return evt;
  }

  @override
  String toString() {
    var tmp = Map<dynamic, dynamic>.from(_data)
      ..remove('icon')
      ..remove('largeIcon');
    return jsonEncode(tmp).toString();
  }
}
